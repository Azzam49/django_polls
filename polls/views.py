#a view is responsible of 2 things:
#return HttpResponse with page content
# or return Http404 error




# get_object_or_404() shortcut to get object from db and
# rasie http404 if object not found.
# render() used in view to render back the request+template
# +context, shortcut of HttpResponse
from django.shortcuts import render,get_object_or_404

# our custom models
from .models import Question,Choice

# loader() to load a template on a variable
from django.template import loader

# use HttpResponseRedirect after succesfully dealing with
# POST data.
from django.http import HttpResponse,HttpResponseRedirect

# use Http404() to raise http404 error
from django.http import Http404

# use reverse() as an alternative to {%url%},
#avoid hard coding the url
from django.urls import reverse

# use F() to avoid race condition
from django.db.models import F

# to use class-based views
from django.views import generic

'''
def pollView(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    context = {
        'latest_question_list': latest_question_list,
    }
    return render(request,"index.html",context)



def detail(request, question_id):
    """
    try:
        #fetch question record for db using question_id arg
        question = Question.objects.get(pk = question_id)
    except Question.DoesNotExist:
        raise Http404("Question does not exist")
    """
    #above is similiar to :
    # get_object_or_404(), returns record or 404 if not found
    # get_list_or_404() this works as filter().
    question = get_object_or_404(Question,pk=question_id)
    context = {
        'question':question,
    }
    return render(request,"detail.html",context)




def results(request, question_id):
    question = get_object_or_404(Question,pk=question_id)
    return render(request,"results.html",{'question':question,})
'''


# generic views - class-based views
# we are going to use here 2 generic views type:
# ListView 'display a list of objects'
# DetailView 'display a detail page for a particular type of object'
# -
# Each generic view needs to know what model it will be acting upon,
# we provide the model using the model attribute.
# -
# DetailView expects the primary key value to be captured from
# the url as "pk" '<int:pk>/' instead of '<int:question_id>/'.
# -
# By default, DetailView generic view uses a template called
# <app name>/<model name>_detail.html in our case, it would
# use the template "polls/question_detail.html",
# the template_name attrivute is used to tell Django to use a
# specfic template name instead of the autogenerated default
# template name.
# -
# Similarly, ListView default's template is <app name>/<model name>_list.html,
# we use template_name to tell ListView to use our existing
# "polls/index.html" template.
# -
# our pervious views, their templates have been provided with a
# context that contains the question and latest_question_list
# context variables.
# For DetailView the question variable is provided automatically
# - since we are using a Django model(Question).
# For ListView,the automatically generated context variable is
# question_list. To override this we provide the context_object_name 
# attribute, specifying that we want to use latest_question_list
# instead.


class IndexView(generic.ListView):
    template_name = "index.html"
    context_object_name = "latest_question_list"

    # override the get_queryset method of the class view
    # to add our logic for retreiving objects.
    def get_queryset(self):
        #returns the last five published questions.
        return Question.objects.order_by('-pub_date')[:5]


class DetailView(generic.DetailView):
    model = Question
    template_name = "detail.html"


class ResultsView(generic.DetailView):
    model = Question
    template_name = "results.html"



def vote(request, question_id):
    #gets question of the selected choice
    question = get_object_or_404(Question,pk = question_id)
    try:
        #gets the selected choice using request.POST['choice'],
        #value of the choosed radio button
        selected_choice = question.choice_set.get(pk = request.POST['choice'])
    #dispay KeyError if Choice does not exists
    except (KeyError, Choice.DoesNotExist):
        # Redisplay the question voting form.
        return render(request,'detial.html',{
            'question':question,
            'error_message': "You didn't select a choice.",
        })
    else:
        #increment votes for the selected choice and save it
        #selected_choice.votes += 1
        
        #our above incrementing have a bug if 2 users on same
        #time is incrementing , that is votes will be updated 
        #for once, we use F() to aboid race condition
        selected_choice.votes = F('votes') + 1
        selected_choice.save()

        # Always return an HttpResponseRedirect after successfully dealing
        # with POST data. This prevents data from being posted twice if a
        # user hits the Back button.
        return HttpResponseRedirect(reverse('polls:results', args=(question.id,)))
        #HttpResponseRedirect take single arg, the url of page
        
        #reverse() is similiar to {% url %} in templates,
        #it avoid us to hard code the url, laos it all us to
        #args and kwargs.



